// === НАЧАЛО: Vision Encoder STARVECTOR ===\nggml_tensor * ggml_vision_encoder(ggml_context * ctx0, const starvector_model *sv, ggml_tensor * image_tensor) {\n    ggml_tensor * cur = image_tensor;\n\n    // 1. Conv1\n    if (sv->img_conv1_weight)\n        cur = ggml_mul_mat(ctx0, sv->img_conv1_weight, cur);\n\n    // 2. Добавить positional embedding, если есть\n    if (sv->img_positional_embedding)\n        cur = ggml_add(ctx0, cur, sv->img_positional_embedding);\n\n    // 3. LayerNorm pre\n    if (sv->img_ln_pre_weight)\n        cur = ggml_norm(ctx0, cur, sv->img_ln_pre_weight, nullptr);\n\n    // 4. Проход по resblock'ам (attention + MLP + LN)\n    int n_resblocks = (int)sv->img_resblock_attn_weights.size();\n    for (int il = 0; il < n_resblocks; ++il) {\n        // Attention (ViT-style self-attention)\n        ggml_tensor * attn = ggml_mul_mat(ctx0, sv->img_resblock_attn_weights[il], cur);\n        attn = ggml_soft_max(ctx0, attn);\n        cur = ggml_add(ctx0, cur, attn); // residual\n\n        // MLP\n        ggml_tensor * mlp = ggml_mul_mat(ctx0, sv->img_resblock_mlp_weights[il], cur);\n        mlp = ggml_gelu(ctx0, mlp);\n        cur = ggml_add(ctx0, cur, mlp); // residual\n\n        // LayerNorm\n        if (il < (int)sv->img_resblock_ln_weights.size())\n            cur = ggml_norm(ctx0, cur, sv->img_resblock_ln_weights[il], nullptr);\n    }\n\n    // 5. Класс-эмбеддинг (ViT-style)\n    if (sv->img_class_embedding)\n        cur = ggml_add(ctx0, cur, sv->img_class_embedding);\n\n    // 6. Финальный LayerNorm vision encoder\n    if (sv->img_ln_vision_weight)\n        cur = ggml_norm(ctx0, cur, sv->img_ln_vision_weight, nullptr);\n\n    return cur;\n}\n// === КОНЕЦ: Vision Encoder STARVECTOR ===\n
